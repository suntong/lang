package xo_mssql

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"time"
)

// BuildVersion represents a row from 'dbo.BuildVersion'.
type BuildVersion struct {
	SystemInformationID bool      `json:"SystemInformationID"` // SystemInformationID
	DatabaseVersion     string    `json:"Database Version"`    // Database Version
	VersionDate         time.Time `json:"VersionDate"`         // VersionDate
	ModifiedDate        time.Time `json:"ModifiedDate"`        // ModifiedDate
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the BuildVersion exists in the database.
func (bv *BuildVersion) Exists() bool {
	return bv._exists
}

// Deleted returns true when the BuildVersion has been marked for deletion from
// the database.
func (bv *BuildVersion) Deleted() bool {
	return bv._deleted
}

// Insert inserts the BuildVersion to the database.
func (bv *BuildVersion) Insert(ctx context.Context, db DB) error {
	switch {
	case bv._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case bv._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO dbo.BuildVersion (` +
		`Database Version, VersionDate, ModifiedDate` +
		`) VALUES (` +
		`@p1, @p2, @p3` +
		`); SELECT ID = CONVERT(BIGINT, SCOPE_IDENTITY())`
	// run
	logf(sqlstr, bv.DatabaseVersion, bv.VersionDate, bv.ModifiedDate)
	rows, err := db.QueryContext(ctx, sqlstr, bv.DatabaseVersion, bv.VersionDate, bv.ModifiedDate)
	if err != nil {
		return logerror(err)
	}
	defer rows.Close()
	// retrieve id
	var id int64
	for rows.Next() {
		if err := rows.Scan(&id); err != nil {
			return logerror(err)
		}
	}
	if err := rows.Err(); err != nil {
		return logerror(err)
	} // set primary key
	bv.SystemInformationID = bool(id)
	// set exists
	bv._exists = true
	return nil
}

// Update updates a BuildVersion in the database.
func (bv *BuildVersion) Update(ctx context.Context, db DB) error {
	switch {
	case !bv._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case bv._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE dbo.BuildVersion SET ` +
		`Database Version = @p1, VersionDate = @p2, ModifiedDate = @p3 ` +
		`WHERE SystemInformationID = @p4`
	// run
	logf(sqlstr, bv.DatabaseVersion, bv.VersionDate, bv.ModifiedDate, bv.SystemInformationID)
	if _, err := db.ExecContext(ctx, sqlstr, bv.DatabaseVersion, bv.VersionDate, bv.ModifiedDate, bv.SystemInformationID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the BuildVersion to the database.
func (bv *BuildVersion) Save(ctx context.Context, db DB) error {
	if bv.Exists() {
		return bv.Update(ctx, db)
	}
	return bv.Insert(ctx, db)
}

// Upsert performs an upsert for BuildVersion.
func (bv *BuildVersion) Upsert(ctx context.Context, db DB) error {
	switch {
	case bv._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `MERGE dbo.BuildVersion AS t ` +
		`USING (` +
		`SELECT @p1 SystemInformationID, @p2 Database Version, @p3 VersionDate, @p4 ModifiedDate ` +
		`) AS s ` +
		`ON s.SystemInformationID = t.SystemInformationID ` +
		`WHEN MATCHED THEN ` +
		`UPDATE SET ` +
		`t.Database Version = s.Database Version, t.VersionDate = s.VersionDate, t.ModifiedDate = s.ModifiedDate ` +
		`WHEN NOT MATCHED THEN ` +
		`INSERT (` +
		`Database Version, VersionDate, ModifiedDate` +
		`) VALUES (` +
		`s.Database Version, s.VersionDate, s.ModifiedDate` +
		`);`
	// run
	logf(sqlstr, bv.SystemInformationID, bv.DatabaseVersion, bv.VersionDate, bv.ModifiedDate)
	if _, err := db.ExecContext(ctx, sqlstr, bv.SystemInformationID, bv.DatabaseVersion, bv.VersionDate, bv.ModifiedDate); err != nil {
		return err
	}
	// set exists
	bv._exists = true
	return nil
}

// Delete deletes the BuildVersion from the database.
func (bv *BuildVersion) Delete(ctx context.Context, db DB) error {
	switch {
	case !bv._exists: // doesn't exist
		return nil
	case bv._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM dbo.BuildVersion ` +
		`WHERE SystemInformationID = @p1`
	// run
	logf(sqlstr, bv.SystemInformationID)
	if _, err := db.ExecContext(ctx, sqlstr, bv.SystemInformationID); err != nil {
		return logerror(err)
	}
	// set deleted
	bv._deleted = true
	return nil
}

// BuildVersionBySystemInformationID retrieves a row from 'dbo.BuildVersion' as a BuildVersion.
//
// Generated from index 'PK__BuildVer__35E58ECA8761CA79'.
func BuildVersionBySystemInformationID(ctx context.Context, db DB, systemInformationID bool) (*BuildVersion, error) {
	// query
	const sqlstr = `SELECT ` +
		`SystemInformationID, Database Version, VersionDate, ModifiedDate ` +
		`FROM dbo.BuildVersion ` +
		`WHERE SystemInformationID = @p1`
	// run
	logf(sqlstr, systemInformationID)
	bv := BuildVersion{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, systemInformationID).Scan(&bv.SystemInformationID, &bv.DatabaseVersion, &bv.VersionDate, &bv.ModifiedDate); err != nil {
		return nil, logerror(err)
	}
	return &bv, nil
}
